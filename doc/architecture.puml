@startuml

class HTTPReply {
    + std::uint16_t code;
    + std::string body;
    + std::unordered_map<std::string, std::string> headers
}

class HTTPRequest {
    + std::string uri;
    + std::string method;
    + std::string body;
    + std::unordered_map<std::string, std::string> queryOptions;
    + std::unordered_map<std::string, std::string> headers;
    + std::unordered_map<std::string, std::any> middlewareData;
}

class PipelineConfig {
    + std::string listenerPath;
    + std::string parserPath;
    + std::string senderPath;
    + std::vector<std::string> modulesPaths;
}

interface IClient {
    + send(content: std::vector<std::byte> const &) const: void
    + receive(bytesToRead: std::size_t): std::vector<std::byte>
    + connect(ip: std::uint32_t, port: std::uint16_t): void
    + run(): void
    + getNativeHandle() const noexcept: socket_type
}

interface IListener {
    + using packetReceivedCallback = std::function<void (packet: std::vector<std::byte> &&, client: Client const &)>
    + listen(): void
    + stop(): void
    + onPacket(callback: packetReceivedCallback &&): void noexcept
}

interface IModule {
    + process(request: RequestDataType &, response: ResponseDataType &): void
}

interface IPacketParser<RequestDataType> {
    + parse(rawRequest: std::vector<std::byte> const &): RequestDataType
}

interface IPipelineManager {
    + listen(): void
    + stop(): void
    + loadConfig(): void
    + configurePipeline(PipelineConfig const &config): void
}

interface IReplySender {
    + send(reply: ResponseDataType const &, client: Client const &): void
}

@enduml
